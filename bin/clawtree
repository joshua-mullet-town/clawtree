#!/bin/bash

ROOT_REPO=$(git rev-parse --show-toplevel 2>/dev/null)
if [[ -z "$ROOT_REPO" ]]; then
  echo "üö´ Not inside a git repository."
  exit 1
fi

SESSIONS_DIR="$ROOT_REPO/.clawtree-sessions"
REGISTRY_FILE="$SESSIONS_DIR/registry.json"
CONFIG_FILE="$ROOT_REPO/.clawtree-config"

mkdir -p "$SESSIONS_DIR"

# Initialize registry if it doesn't exist
if [[ ! -f "$REGISTRY_FILE" ]]; then
  echo '{"sessions":{}}' > "$REGISTRY_FILE"
fi

# Check for jq availability and warn if not found
if ! command -v jq >/dev/null 2>&1; then
  echo "‚ö†Ô∏è  Warning: 'jq' not found. Using fallback JSON parsing (less reliable)."
  echo "    Install jq for better performance: brew install jq"
fi

if [[ -f "$CONFIG_FILE" ]]; then
  source "$CONFIG_FILE"
else
  DEFAULT_BASE_BRANCH="main"
fi

function generate_session_id() {
  # Generate a short UUID-like session ID
  echo "session-$(openssl rand -hex 4)"
}

function list_sessions_array() {
  ls "$SESSIONS_DIR" 2>/dev/null | grep -v "registry.json"
}

function get_session_info() {
  local session_id="$1"
  local field="$2"
  if [[ -f "$REGISTRY_FILE" ]]; then
    if command -v jq >/dev/null 2>&1; then
      jq -r ".sessions[\"$session_id\"].$field // empty" "$REGISTRY_FILE" 2>/dev/null
    else
      # Fallback: basic grep parsing
      case "$field" in
        "branch")
          grep -A 3 "\"$session_id\"" "$REGISTRY_FILE" | grep '"branch"' | cut -d'"' -f4 2>/dev/null || echo ""
          ;;
        "sessionDir")
          echo "$session_id"  # Session ID is the directory name
          ;;
      esac
    fi
  fi
}

function add_session_to_registry() {
  local session_id="$1"
  local branch="$2"
  local base_branch="$3"
  local created="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  
  if command -v jq >/dev/null 2>&1; then
    # Use jq for proper JSON manipulation
    local temp_file=$(mktemp)
    jq ".sessions[\"$session_id\"] = {\"branch\": \"$branch\", \"baseBranch\": \"$base_branch\", \"created\": \"$created\", \"sessionDir\": \"$session_id\"}" "$REGISTRY_FILE" > "$temp_file" && mv "$temp_file" "$REGISTRY_FILE"
  else
    # Fallback: manual JSON construction
    local temp_file=$(mktemp)
    
    # Check if this is the first entry
    if grep -q '"sessions":{}' "$REGISTRY_FILE"; then
      # First entry - replace empty sessions object
      echo "{" > "$temp_file"
      echo "  \"sessions\": {" >> "$temp_file"
      echo "    \"$session_id\": {" >> "$temp_file"
      echo "      \"branch\": \"$branch\"," >> "$temp_file"
      echo "      \"baseBranch\": \"$base_branch\"," >> "$temp_file"
      echo "      \"created\": \"$created\"," >> "$temp_file"
      echo "      \"sessionDir\": \"$session_id\"" >> "$temp_file"
      echo "    }" >> "$temp_file"
      echo "  }" >> "$temp_file"
      echo "}" >> "$temp_file"
    else
      # Add to existing sessions
      head -n -2 "$REGISTRY_FILE" > "$temp_file"  # Remove last 2 lines (}} )
      echo "," >> "$temp_file"
      echo "    \"$session_id\": {" >> "$temp_file"
      echo "      \"branch\": \"$branch\"," >> "$temp_file"
      echo "      \"baseBranch\": \"$base_branch\"," >> "$temp_file"
      echo "      \"created\": \"$created\"," >> "$temp_file"
      echo "      \"sessionDir\": \"$session_id\"" >> "$temp_file"
      echo "    }" >> "$temp_file"
      echo "  }" >> "$temp_file"
      echo "}" >> "$temp_file"
    fi
    mv "$temp_file" "$REGISTRY_FILE"
  fi
}

function remove_session_from_registry() {
  local session_id="$1"
  
  if command -v jq >/dev/null 2>&1; then
    local temp_file=$(mktemp)
    jq "del(.sessions[\"$session_id\"])" "$REGISTRY_FILE" > "$temp_file" && mv "$temp_file" "$REGISTRY_FILE"
  else
    # Fallback: recreate JSON without the session
    local temp_file=$(mktemp)
    echo '{"sessions":{' > "$temp_file"
    local first=true
    while IFS= read -r line; do
      local sid=$(echo "$line" | cut -d' ' -f1)
      if [[ "$sid" != "$session_id" ]]; then
        if [[ "$first" != true ]]; then
          echo "," >> "$temp_file"
        fi
        local branch=$(get_session_info "$sid" "branch")
        local base_branch=$(get_session_info "$sid" "baseBranch")
        echo "  \"$sid\": {\"branch\": \"$branch\", \"baseBranch\": \"$base_branch\", \"sessionDir\": \"$sid\"}" >> "$temp_file"
        first=false
      fi
    done < <(list_sessions_array)
    echo '}}' >> "$temp_file"
    mv "$temp_file" "$REGISTRY_FILE"
  fi
}

function detect_default_branch() {
  # Try to get the remote HEAD first
  local remote_head=$(git -C "$ROOT_REPO" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's|refs/remotes/origin/||')
  if [[ -n "$remote_head" ]] && git -C "$ROOT_REPO" show-ref --verify --quiet "refs/heads/$remote_head"; then
    echo "$remote_head"
    return
  fi
  
  # Fallback to common branch names that exist locally
  for branch in main master develop development; do
    if git -C "$ROOT_REPO" show-ref --verify --quiet "refs/heads/$branch"; then
      echo "$branch"
      return
    fi
  done
  
  # Last resort: get the first local branch
  local first_branch=$(git -C "$ROOT_REPO" branch --format='%(refname:short)' | head -n1)
  if [[ -n "$first_branch" ]]; then
    echo "$first_branch"
  else
    echo "main"  # Ultimate fallback
  fi
}

function validate_branch_exists() {
  local branch="$1"
  git -C "$ROOT_REPO" show-ref --verify --quiet "refs/heads/$branch"
}

function list_available_branches() {
  git -C "$ROOT_REPO" branch --format='%(refname:short)' | tr '\n' ', ' | sed 's/, $//'
}

function get_latest_tag() {
  git -C "$ROOT_REPO" describe --tags --abbrev=0 2>/dev/null
}

function list_available_tags() {
  git -C "$ROOT_REPO" tag --sort=-version:refname | head -10 | tr '\n' ', ' | sed 's/, $//'
}

function validate_tag_exists() {
  local tag="$1"
  git -C "$ROOT_REPO" show-ref --verify --quiet "refs/tags/$tag"
}

function detect_copy_candidates() {
  local candidates=()
  
  # Find top-level node_modules directories and count total nested ones
  local toplevel_dirs=()
  local total_nested=0
  
  while IFS= read -r -d '' nm_dir; do
    local rel_path="${nm_dir#$ROOT_REPO/}"
    if [[ ! "$rel_path" =~ node_modules.*node_modules ]]; then
      # This is a top-level node_modules
      local size=$(du -sh "$nm_dir" 2>/dev/null | cut -f1)
      toplevel_dirs+=("$rel_path ($size)")
    fi
    total_nested=$((total_nested + 1))
  done < <(find "$ROOT_REPO" -name "node_modules" -type d -print0 2>/dev/null)
  
  if [[ ${#toplevel_dirs[@]} -gt 0 ]]; then
    candidates+=("üì¶ All dependencies (${#toplevel_dirs[@]} main dirs, $total_nested total) - skips npm install")
    for dir in "${toplevel_dirs[@]}"; do
      candidates+=("   ‚Ä¢ $dir")
    done
  fi
  
  # Find all .env files
  while IFS= read -r -d '' env_file; do
    local rel_path="${env_file#$ROOT_REPO/}"
    candidates+=("üîê $rel_path - environment config")
  done < <(find "$ROOT_REPO" -name ".env*" -type f -print0 2>/dev/null)
  
  # Output candidates if any found
  if [[ ${#candidates[@]} -gt 0 ]]; then
    printf "%s\n" "${candidates[@]}"
  fi
}

function copy_smart_dependencies() {
  local dest_path="$1"
  local copy_mode="$2"  # "all", "selective", or "none"
  
  if [[ "$copy_mode" == "none" ]]; then
    return 0
  fi
  
  echo "üì¶ Copying dependencies to speed up setup..."
  
  # Copy ALL node_modules directories (including nested ones - that's the whole point!)
  local copy_nm=true
  if [[ "$copy_mode" == "selective" ]]; then
    if ! gum confirm "Copy all node_modules directories? (skips npm install)"; then
      copy_nm=false
      echo "  ‚è≠Ô∏è  Skipped node_modules"
    fi
  fi
  
  if [[ "$copy_nm" == "true" ]]; then
    echo "  üöÄ Copying all node_modules directories..."
    # Copy top-level node_modules directories (which include all their nested contents)
    while IFS= read -r -d '' nm_dir; do
      if [[ -d "$nm_dir" ]]; then
        local rel_path="${nm_dir#$ROOT_REPO/}"
        # Only copy top-level ones (not nested inside other node_modules)
        if [[ ! "$rel_path" =~ node_modules.*node_modules ]]; then
          local dest_dir="$dest_path/$(dirname "$rel_path")"
          mkdir -p "$dest_dir"
          cp -R "$nm_dir" "$dest_dir/" 2>/dev/null
          echo "    ‚úÖ Copied $rel_path (includes all nested dependencies)"
        fi
      fi
    done < <(find "$ROOT_REPO" -name "node_modules" -type d -print0 2>/dev/null)
  fi
  
  # Copy all .env files
  while IFS= read -r -d '' env_file; do
    if [[ -f "$env_file" ]]; then
      local rel_path="${env_file#$ROOT_REPO/}"
      local dest_dir="$dest_path/$(dirname "$rel_path")"
      mkdir -p "$dest_dir"
      
      if [[ "$copy_mode" == "selective" ]]; then
        if gum confirm "Copy $rel_path?"; then
          cp "$env_file" "$dest_dir/" 2>/dev/null
          echo "  ‚úÖ Copied $rel_path"
        else
          echo "  ‚è≠Ô∏è  Skipped $rel_path"
        fi
      else
        cp "$env_file" "$dest_dir/" 2>/dev/null
        echo "  ‚úÖ Copied $rel_path"
      fi
    fi
  done < <(find "$ROOT_REPO" -name ".env*" -type f -print0 2>/dev/null)
}

function sanitize_branch_name() {
  local original="$1"
  # Replace spaces with hyphens, remove other invalid characters
  local sanitized=$(echo "$original" | sed 's/ /-/g' | sed 's/[^a-zA-Z0-9/_-]//g')
  echo "$sanitized"
}

function create_session() {
  # Get branch name
  while true; do
    branch=$(gum input --placeholder "New branch name (e.g. fix/gh-1083)")
    if [ -z "$branch" ]; then
      echo "üö´ No branch name provided."
      return
    fi
    
    # Check if branch name needs sanitizing
    sanitized=$(sanitize_branch_name "$branch")
    if [[ "$branch" != "$sanitized" ]]; then
      echo "‚ö†Ô∏è  Branch name contains invalid characters."
      echo "   Original: '$branch'"
      echo "   Suggested: '$sanitized'"
      
      choice=$(gum choose --header "What would you like to do?" \
        "‚úÖ Use suggested name: '$sanitized'" \
        "‚úèÔ∏è  Enter a different name" \
        "‚ùå Cancel")
      
      case "$choice" in
        "‚úÖ Use suggested name:"*)
          branch="$sanitized"
          break
          ;;
        "‚úèÔ∏è  Enter a different name")
          continue
          ;;
        "‚ùå Cancel")
          return
          ;;
      esac
    else
      break
    fi
  done

  # Detect smart default and update DEFAULT_BASE_BRANCH if needed
  if [[ -z "$DEFAULT_BASE_BRANCH" ]] || [[ "$DEFAULT_BASE_BRANCH" == "main" ]]; then
    smart_default=$(detect_default_branch)
    if [[ "$smart_default" != "$DEFAULT_BASE_BRANCH" ]]; then
      DEFAULT_BASE_BRANCH="$smart_default"
    fi
  fi

  # Ask user to choose between branch or tag
  source_type=$(gum choose --header "What should this new worktree branch from?" "üìã Branch" "üè∑Ô∏è Tag (latest)" "üè∑Ô∏è Tag (specify)")
  
  if [[ "$source_type" == "üìã Branch" ]]; then
    while true; do
      # Show clear prompt with helper text
      base=$(gum input --header "Which branch should this new worktree branch from?" --placeholder "Base branch to create from" --value "$DEFAULT_BASE_BRANCH")
      if [ -z "$base" ]; then
        echo "üö´ No base branch provided."
        return
      fi

      # Validate that the branch exists
      if validate_branch_exists "$base"; then
        break
      else
        available_branches=$(list_available_branches)
        echo "‚ùå Branch '$base' does not exist. Available branches: $available_branches"
        
        retry_choice=$(gum choose --header "What would you like to do?" "üîÑ Try again" "‚ùå Cancel")
        if [[ "$retry_choice" == "‚ùå Cancel" ]]; then
          return
        fi
        # Continue loop to try again
      fi
    done
  elif [[ "$source_type" == "üè∑Ô∏è Tag (latest)" ]]; then
    base=$(get_latest_tag)
    if [ -z "$base" ]; then
      echo "‚ùå No tags found in this repository."
      return
    fi
    echo "üìå Using latest tag: $base"
  else # Tag (specify)
    latest_tag=$(get_latest_tag)
    available_tags=$(list_available_tags)
    echo "üí° Latest tag: $latest_tag"
    echo "üìã Recent tags: $available_tags"
    
    while true; do
      base=$(gum input --header "Which tag should this new worktree branch from?" --placeholder "Tag name (e.g. v1.0.1)" --value "$latest_tag")
      if [ -z "$base" ]; then
        echo "üö´ No tag provided."
        return
      fi

      # Validate that the tag exists
      if validate_tag_exists "$base"; then
        break
      else
        echo "‚ùå Tag '$base' does not exist. Available tags: $available_tags"
        
        retry_choice=$(gum choose --header "What would you like to do?" "üîÑ Try again" "‚ùå Cancel")
        if [[ "$retry_choice" == "‚ùå Cancel" ]]; then
          return
        fi
        # Continue loop to try again
      fi
    done
  fi

  # Save new default if different (only for branches)
  if [[ "$source_type" == "üìã Branch" ]] && [[ "$base" != "$DEFAULT_BASE_BRANCH" ]]; then
    echo "DEFAULT_BASE_BRANCH=$base" > "$CONFIG_FILE"
    echo "üìÅ Saved '$base' as default base branch for this repo."
    DEFAULT_BASE_BRANCH="$base"
  fi

  # Detect what we can copy to speed up setup
  copy_candidates=$(detect_copy_candidates)
  
  if [[ -n "$copy_candidates" ]]; then
    echo "üöÄ Found items that can speed up your setup:"
    echo "$copy_candidates"
    echo ""
    
    copy_choice=$(gum choose --header "Speed up setup by copying dependencies?" \
      "üì¶ Copy all detected items (faster setup)" \
      "üéØ Let me choose what to copy" \
      "üßπ Fresh start (no copying)")
  else
    copy_choice="üßπ Fresh start (no copying)"
  fi

  # Create the worktree using branch name for directory (convert slashes to hyphens)
  session_name="$(echo $branch | tr '/' '-')"
  path="$SESSIONS_DIR/$session_name"
  
  if git -C "$ROOT_REPO" worktree add "$path" -b "$branch" "$base" 2>/dev/null; then
    # Store ALL the metadata we need for this session
    echo "$branch" > "$path/.clawtree-branch-name"
    echo "$base" > "$path/.clawtree-base-branch"
    echo "$source_type" > "$path/.clawtree-source-type"
    
    if [[ "$source_type" == "üìã Branch" ]]; then
      echo "‚úÖ Worktree created: $path (branch '$branch' from $base)"
    else
      echo "‚úÖ Worktree created: $path (branch '$branch' from tag $base)"
    fi
    
    # Copy dependencies based on user choice
    case "$copy_choice" in
      "üì¶ Copy all detected items (faster setup)")
        copy_smart_dependencies "$path" "all"
        ;;
      "üéØ Let me choose what to copy")
        copy_smart_dependencies "$path" "selective"
        ;;
      *)
        # Fresh start - no copying
        ;;
    esac
    
    echo "‚úÖ Session '$session_name' created successfully!"
    
    # Show the same menu as when selecting an existing session
    show_session_menu "$session_name"
  else
    echo "‚ùå Failed to create worktree. The branch '$branch' may already exist."
  fi
}

function delete_session() {
  session="$1"
  skip_confirm="$2"  # "skip" to bypass confirmation
  path="$SESSIONS_DIR/$session"

  # Get the actual branch name from stored metadata
  stored_branch=$(get_stored_branch_name "$session")
  
  # Skip confirmation if called from merge-back
  if [[ "$skip_confirm" == "skip" ]] || gum confirm "Delete session '$session'?"; then
    # Force remove worktree (handles modified files)
    if git -C "$ROOT_REPO" worktree remove --force "$path" 2>/dev/null; then
      echo "‚úÖ Removed worktree: $session"
    else
      echo "‚ö†Ô∏è Worktree already removed"
    fi
    
    # Use stored branch name if available, otherwise try conversion
    if [[ -n "$stored_branch" ]]; then
      if git -C "$ROOT_REPO" branch -D "$stored_branch" 2>/dev/null; then
        echo "‚úÖ Deleted branch: $stored_branch"
      else
        echo "‚ö†Ô∏è Branch '$stored_branch' not found"
      fi
    else
      # Fallback for old sessions without stored metadata
      if [[ "$session" =~ ^session- ]]; then
        # Old UUID-based sessions
        branch_name=$(echo "$session" | tr '-' '/')
        if git -C "$ROOT_REPO" branch -D "$branch_name" 2>/dev/null; then
          echo "‚úÖ Deleted branch: $branch_name"
        else
          echo "‚ö†Ô∏è Branch not found (old session)"
        fi
      else
        # Try converting session name back to branch name
        branch_name=$(echo "$session" | tr '-' '/')
        if git -C "$ROOT_REPO" branch -D "$branch_name" 2>/dev/null; then
          echo "‚úÖ Deleted branch: $branch_name"
        else
          echo "‚ö†Ô∏è Branch '$branch_name' not found"
        fi
      fi
    fi
    
    echo "üóëÔ∏è Session '$session' deleted"
  fi
}

function show_session_menu() {
  local session="$1"
  
  gum style --bold "Selected: $session"
  
  # Check if this session supports merge back
  base_branch=$(get_base_branch "$session")
  source_type=$(get_source_type "$session")
  
  if [[ -n "$base_branch" ]] && [[ "$source_type" == "üìã Branch" ]]; then
    action=$(gum choose "üí¨ Launch Claude" "üíª Open in VS Code" "ü§ñ Launch Both" "üîÑ Merge & Delete Session" "üîÑ Merge & Keep Session" "üìù Edit Description" "üóëÔ∏è Delete Session" "‚ùå Cancel")
  else
    action=$(gum choose "üí¨ Launch Claude" "üíª Open in VS Code" "ü§ñ Launch Both" "üìù Edit Description" "üóëÔ∏è Delete Session" "‚ùå Cancel")
  fi

  case $action in
    "üí¨ Launch Claude")
      open_session "$session"
      ;;
    "üíª Open in VS Code")
      open_vscode "$session"
      ;;
    "ü§ñ Launch Both")
      open_vscode "$session"
      open_session "$session"
      ;;
    "üîÑ Merge & Delete Session")
      merge_back_to_base "$session" "delete"
      ;;
    "üîÑ Merge & Keep Session")
      merge_back_to_base "$session" "keep"
      ;;
    "üìù Edit Description")
      set_session_description "$session"
      ;;
    "üóëÔ∏è Delete Session")
      delete_session "$session"
      ;;
    "‚ùå Cancel")
      ;;
  esac
}

function launch_in_terminal() {
  local path="$1"
  local claude_cmd="$2"
  
  osascript <<EOF
tell application "Terminal"
  do script "cd \"$path\" && $claude_cmd"
  activate
end tell
EOF
}

function launch_in_iterm() {
  local path="$1"
  local claude_cmd="$2"
  
  osascript <<EOF
tell application "iTerm2"
  create window with default profile
  tell current session of current window
    write text "cd \"$path\" && $claude_cmd"
  end tell
  activate
end tell
EOF
}

function open_session() {
  local session_id="$1"
  local path="$SESSIONS_DIR/$session_id"
  
  # Build claude command with common options (always use pure Sonnet)
  claude_cmd="claude --model sonnet"
  
  # Quick launch options - only show if we have common use cases
  launch_option=$(gum choose --header "Launch Claude with:" "üöÄ Standard" "‚ö° Skip permissions" "üîÑ Resume session" "‚öôÔ∏è Custom flags" "‚ùå Cancel")
  
  case $launch_option in
    "‚ö° Skip permissions")
      claude_cmd="claude --model sonnet --dangerously-skip-permissions"
      ;;
    "üîÑ Resume session")
      claude_cmd="claude --model sonnet --resume"
      ;;
    "‚öôÔ∏è Custom flags")
      flags=$(gum input --placeholder "Additional flags (e.g. --resume --dangerously-skip-permissions)")
      if [[ -n "$flags" ]]; then
        claude_cmd="claude --model sonnet $flags"
      else
        claude_cmd="claude --model sonnet"
      fi
      ;;
    "‚ùå Cancel")
      return  # Exit without launching anything
      ;;
    *)
      claude_cmd="claude --model sonnet"
      ;;
  esac
  
  # Auto-detect and default to iTerm2 if available
  if ls /Applications/iTerm.app 2>/dev/null >/dev/null || osascript -e 'tell application "System Events" to return (exists application process "iTerm2")' 2>/dev/null; then
    # iTerm2 is available - default to it but offer choice
    terminal_choice=$(gum choose --header "Choose terminal (iTerm2 recommended):" "üöÄ iTerm (default)" "üíª Terminal" "‚ùå Cancel")
    
    case $terminal_choice in
      "üöÄ iTerm (default)")
        launch_in_iterm "$path" "$claude_cmd"
        ;;
      "üíª Terminal")
        launch_in_terminal "$path" "$claude_cmd"
        ;;
      "‚ùå Cancel")
        return
        ;;
    esac
  else
    # No iTerm2 - use Terminal directly
    echo "üöÄ Opening in Terminal..."
    launch_in_terminal "$path" "$claude_cmd"
  fi
}

function open_vscode() {
  local session_id="$1"
  local path="$SESSIONS_DIR/$session_id"
  
  # Try different ways to open VS Code
  if command -v code &> /dev/null; then
    code "$path"
  elif [[ -d "/Applications/Visual Studio Code.app" ]]; then
    open -a "Visual Studio Code" "$path"
  else
    echo "‚ö†Ô∏è  VS Code not found. Please install VS Code or add 'code' command to PATH."
    echo "    You can install the CLI by opening VS Code and running:"
    echo "    Command Palette (‚åò‚áßP) ‚Üí 'Shell Command: Install code command in PATH'"
  fi
}


function get_stored_branch_name() {
  local session="$1"
  local path="$SESSIONS_DIR/$session"
  
  if [[ -f "$path/.clawtree-branch-name" ]]; then
    cat "$path/.clawtree-branch-name"
  else
    echo ""  # No branch name stored
  fi
}

function get_base_branch() {
  local session="$1"
  local path="$SESSIONS_DIR/$session"
  
  if [[ -f "$path/.clawtree-base-branch" ]]; then
    cat "$path/.clawtree-base-branch"
  else
    echo ""  # No base branch info found
  fi
}

function get_source_type() {
  local session="$1"
  local path="$SESSIONS_DIR/$session"
  
  if [[ -f "$path/.clawtree-source-type" ]]; then
    cat "$path/.clawtree-source-type"
  else
    echo "üìã Branch"  # Default to branch
  fi
}

function get_session_description() {
  local session="$1"
  local path="$SESSIONS_DIR/$session"
  
  if [[ -f "$path/.clawtree-description" ]]; then
    cat "$path/.clawtree-description"
  else
    echo ""  # No description
  fi
}

function set_session_description() {
  local session="$1"
  local path="$SESSIONS_DIR/$session"
  
  echo "üìù Add a description for this session (optional)"
  echo "   Current: $(get_session_description "$session" || echo "none")"
  echo ""
  
  description=$(gum input --placeholder "Brief description (leave empty to remove)" --value "$(get_session_description "$session")")
  
  if [[ -n "$description" ]]; then
    echo "$description" > "$path/.clawtree-description"
    echo "‚úÖ Description saved: $description"
  else
    rm -f "$path/.clawtree-description"
    echo "üóëÔ∏è Description removed"
  fi
}

function merge_back_to_base() {
  local session="$1"
  local delete_after="$2"  # "delete" or "keep"
  local path="$SESSIONS_DIR/$session"
  local branch=$(get_stored_branch_name "$session")
  local base_branch=$(get_base_branch "$session")
  local source_type=$(get_source_type "$session")
  
  # If no stored branch name, fall back to conversion
  if [[ -z "$branch" ]]; then
    branch=$(echo "$session" | tr '-' '/')
  fi
  
  # Validate that we have base branch info
  if [[ -z "$base_branch" ]]; then
    echo "‚ùå Cannot merge: No base branch information found for this session."
    echo "    This may be an older session created before merge-back support."
    return 1
  fi
  
  # Don't allow merging back to tags
  if [[ "$source_type" != "üìã Branch" ]]; then
    echo "‚ùå Cannot merge back to a tag. This session was created from: $source_type"
    return 1
  fi
  
  # Validate that base branch still exists
  if ! validate_branch_exists "$base_branch"; then
    echo "‚ùå Base branch '$base_branch' no longer exists."
    return 1
  fi
  
  echo "üîÑ Merge Back Summary:"
  echo "  Session: $session"
  echo "  Branch: $branch"
  echo "  Target: $base_branch"
  echo ""
  
  # Check if there are uncommitted changes in the session
  if ! git -C "$path" diff --quiet || ! git -C "$path" diff --cached --quiet; then
    echo "‚ö†Ô∏è  Warning: Uncommitted changes detected in session."
    commit_first=$(gum choose --header "What would you like to do?" "üíæ Commit changes first" "üß® Stash changes and continue" "‚ùå Cancel merge")
    
    case $commit_first in
      "üíæ Commit changes first")
        echo "üìù Please commit your changes in the session, then try merge again."
        return 1
        ;;
      "üß® Stash changes and continue")
        echo "üß® Stashing uncommitted changes..."
        git -C "$path" stash push -m "clawtree: stashed before merge back to $base_branch"
        ;;
      "‚ùå Cancel merge")
        return 1
        ;;
    esac
  fi
  
  # Final confirmation
  if ! gum confirm "Proceed with merging '$branch' into '$base_branch'?"; then
    return 1
  fi
  
  echo "üîÑ Starting merge process..."
  
  # Check for uncommitted changes in main repo before checkout
  if ! git -C "$ROOT_REPO" diff --quiet || ! git -C "$ROOT_REPO" diff --cached --quiet; then
    echo "‚ö†Ô∏è  Warning: Uncommitted changes detected in main repository."
    echo "    These changes could interfere with the checkout and merge process."
    main_repo_action=$(gum choose --header "What would you like to do?" "üíæ Commit changes in main repo first" "üß® Stash changes and continue" "‚ùå Cancel merge")
    
    case $main_repo_action in
      "üíæ Commit changes in main repo first")
        echo "üìù Please commit your changes in the main repo, then try merge again."
        return 1
        ;;
      "üß® Stash changes and continue")
        echo "üß® Stashing uncommitted changes in main repo..."
        git -C "$ROOT_REPO" stash push -m "clawtree: stashed before merge of $branch"
        ;;
      "‚ùå Cancel merge")
        return 1
        ;;
    esac
  fi
  
  # Switch to base branch in main repo
  if ! git -C "$ROOT_REPO" checkout "$base_branch" 2>/dev/null; then
    echo "‚ùå Failed to checkout base branch '$base_branch'"
    return 1
  fi
  
  # Pull latest changes (if remote tracking exists)
  if git -C "$ROOT_REPO" rev-parse --abbrev-ref "$base_branch@{upstream}" >/dev/null 2>&1; then
    echo "üîÑ Pulling latest changes for $base_branch..."
    git -C "$ROOT_REPO" pull
  fi
  
  # Perform the merge
  if git -C "$ROOT_REPO" merge "$branch" --no-ff -m "Merge branch '$branch' (from clawtree session $session)" 2>/dev/null; then
    echo "‚úÖ Successfully merged '$branch' into '$base_branch'"
    
    # Handle session cleanup based on user's upfront choice
    if [[ "$delete_after" == "delete" ]]; then
      echo "üóëÔ∏è Cleaning up session as requested..."
      delete_session "$session" "skip"
    else
      echo "üìù Session '$session' kept for reference."
    fi
  else
    echo "‚ùå Merge failed! There may be conflicts that need manual resolution."
    echo "    You can resolve conflicts in the main repo and complete the merge manually."
    return 1
  fi
}

function check_session_status() {
  local session="$1"
  local path="$SESSIONS_DIR/$session"
  
  if [[ ! -d "$path" ]]; then
    echo "‚ùå"  # Missing directory
    return
  fi
  
  # Check for uncommitted changes
  if ! git -C "$path" diff --quiet 2>/dev/null || ! git -C "$path" diff --cached --quiet 2>/dev/null; then
    echo "üü°"  # Uncommitted changes
  else
    echo "üü¢"  # Clean
  fi
}

function format_session_display() {
  local session_id="$1"
  local status=$(check_session_status "$session_id")
  local branch=$(get_stored_branch_name "$session_id")
  local description=$(get_session_description "$session_id")
  
  if [[ -z "$branch" ]]; then
    branch=$(echo "$session_id" | tr '-' '/')
  fi
  
  # Only show arrow if branch name is different from session name
  local session_as_branch=$(echo "$session_id" | tr '-' '/')
  if [[ "$branch" == "$session_as_branch" ]] || [[ "$branch" == "$session_id" ]]; then
    # Branch and session name are the same, just show session
    if [[ -n "$description" ]]; then
      echo "$status $session_id \"$description\""
    else
      echo "$status $session_id"
    fi
  else
    # Branch is different, show the arrow
    if [[ -n "$description" ]]; then
      echo "$status $session_id ‚Üí $branch \"$description\""
    else
      echo "$status $session_id ‚Üí $branch"
    fi
  fi
}

function dashboard() {
  while true; do
    options=()
    session_map=()  # Track original session names
    
    while IFS= read -r session; do
      formatted=$(format_session_display "$session")
      options+=("$formatted")
      session_map+=("$session")
    done < <(list_sessions_array)

    options+=("‚ûï New Session")
    options+=("‚ùå Exit")

    if [[ ${#session_map[@]} -gt 0 ]]; then
      header="üß† Clawtree Sessions (üü¢=clean üü°=changes ‚ùå=error)"
    else
      header="üß† Clawtree Sessions"
    fi

    choice=$(printf "%s\n" "${options[@]}" | gum choose --header="$header")

    if [[ "$choice" == "‚ûï New Session" ]]; then
      create_session
    elif [[ "$choice" == "‚ùå Exit" ]]; then
      break
    elif [[ -n "$choice" ]]; then
      # Find the original session name from the formatted choice
      for i in "${!session_map[@]}"; do
        if [[ "${options[$i]}" == "$choice" ]]; then
          show_session_menu "${session_map[$i]}"
          break
        fi
      done
    fi
  done
}

dashboard
