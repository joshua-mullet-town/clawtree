#!/bin/bash

ROOT_REPO=$(git rev-parse --show-toplevel 2>/dev/null)
if [[ -z "$ROOT_REPO" ]]; then
  echo "üö´ Not inside a git repository."
  exit 1
fi

SESSIONS_DIR="$ROOT_REPO/.clawtree-sessions"
REGISTRY_FILE="$SESSIONS_DIR/registry.json"
CONFIG_FILE="$ROOT_REPO/.clawtree-config"

mkdir -p "$SESSIONS_DIR"

# Initialize registry if it doesn't exist
if [[ ! -f "$REGISTRY_FILE" ]]; then
  echo '{"sessions":{}}' > "$REGISTRY_FILE"
fi

# Check for jq availability and warn if not found
if ! command -v jq >/dev/null 2>&1; then
  echo "‚ö†Ô∏è  Warning: 'jq' not found. Using fallback JSON parsing (less reliable)."
  echo "    Install jq for better performance: brew install jq"
fi

if [[ -f "$CONFIG_FILE" ]]; then
  source "$CONFIG_FILE"
else
  DEFAULT_BASE_BRANCH="main"
fi

function generate_session_id() {
  # Generate a short UUID-like session ID
  echo "session-$(openssl rand -hex 4)"
}

function list_sessions_array() {
  # List sessions from registry, showing friendly names
  if [[ -f "$REGISTRY_FILE" ]]; then
    if command -v jq >/dev/null 2>&1; then
      jq -r '.sessions | to_entries[] | "\(.key) (\(.value.branch))"' "$REGISTRY_FILE" 2>/dev/null | awk '{print $1}'
    else
      # Fallback: parse JSON manually
      grep -o '"session-[^"]*"' "$REGISTRY_FILE" 2>/dev/null | tr -d '"' || true
    fi
  fi
}

function get_session_info() {
  local session_id="$1"
  local field="$2"
  if [[ -f "$REGISTRY_FILE" ]]; then
    if command -v jq >/dev/null 2>&1; then
      jq -r ".sessions[\"$session_id\"].$field // empty" "$REGISTRY_FILE" 2>/dev/null
    else
      # Fallback: basic grep parsing
      case "$field" in
        "branch")
          grep -A 3 "\"$session_id\"" "$REGISTRY_FILE" | grep '"branch"' | cut -d'"' -f4 2>/dev/null || echo ""
          ;;
        "sessionDir")
          echo "$session_id"  # Session ID is the directory name
          ;;
      esac
    fi
  fi
}

function add_session_to_registry() {
  local session_id="$1"
  local branch="$2"
  local base_branch="$3"
  local created="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  
  if command -v jq >/dev/null 2>&1; then
    # Use jq for proper JSON manipulation
    local temp_file=$(mktemp)
    jq ".sessions[\"$session_id\"] = {\"branch\": \"$branch\", \"baseBranch\": \"$base_branch\", \"created\": \"$created\", \"sessionDir\": \"$session_id\"}" "$REGISTRY_FILE" > "$temp_file" && mv "$temp_file" "$REGISTRY_FILE"
  else
    # Fallback: manual JSON construction
    local temp_file=$(mktemp)
    
    # Check if this is the first entry
    if grep -q '"sessions":{}' "$REGISTRY_FILE"; then
      # First entry - replace empty sessions object
      echo "{" > "$temp_file"
      echo "  \"sessions\": {" >> "$temp_file"
      echo "    \"$session_id\": {" >> "$temp_file"
      echo "      \"branch\": \"$branch\"," >> "$temp_file"
      echo "      \"baseBranch\": \"$base_branch\"," >> "$temp_file"
      echo "      \"created\": \"$created\"," >> "$temp_file"
      echo "      \"sessionDir\": \"$session_id\"" >> "$temp_file"
      echo "    }" >> "$temp_file"
      echo "  }" >> "$temp_file"
      echo "}" >> "$temp_file"
    else
      # Add to existing sessions
      head -n -2 "$REGISTRY_FILE" > "$temp_file"  # Remove last 2 lines (}} )
      echo "," >> "$temp_file"
      echo "    \"$session_id\": {" >> "$temp_file"
      echo "      \"branch\": \"$branch\"," >> "$temp_file"
      echo "      \"baseBranch\": \"$base_branch\"," >> "$temp_file"
      echo "      \"created\": \"$created\"," >> "$temp_file"
      echo "      \"sessionDir\": \"$session_id\"" >> "$temp_file"
      echo "    }" >> "$temp_file"
      echo "  }" >> "$temp_file"
      echo "}" >> "$temp_file"
    fi
    mv "$temp_file" "$REGISTRY_FILE"
  fi
}

function remove_session_from_registry() {
  local session_id="$1"
  
  if command -v jq >/dev/null 2>&1; then
    local temp_file=$(mktemp)
    jq "del(.sessions[\"$session_id\"])" "$REGISTRY_FILE" > "$temp_file" && mv "$temp_file" "$REGISTRY_FILE"
  else
    # Fallback: recreate JSON without the session
    local temp_file=$(mktemp)
    echo '{"sessions":{' > "$temp_file"
    local first=true
    while IFS= read -r line; do
      local sid=$(echo "$line" | cut -d' ' -f1)
      if [[ "$sid" != "$session_id" ]]; then
        if [[ "$first" != true ]]; then
          echo "," >> "$temp_file"
        fi
        local branch=$(get_session_info "$sid" "branch")
        local base_branch=$(get_session_info "$sid" "baseBranch")
        echo "  \"$sid\": {\"branch\": \"$branch\", \"baseBranch\": \"$base_branch\", \"sessionDir\": \"$sid\"}" >> "$temp_file"
        first=false
      fi
    done < <(list_sessions_array)
    echo '}}' >> "$temp_file"
    mv "$temp_file" "$REGISTRY_FILE"
  fi
}

function detect_default_branch() {
  # Try to get the remote HEAD first
  local remote_head=$(git -C "$ROOT_REPO" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's|refs/remotes/origin/||')
  if [[ -n "$remote_head" ]] && git -C "$ROOT_REPO" show-ref --verify --quiet "refs/heads/$remote_head"; then
    echo "$remote_head"
    return
  fi
  
  # Fallback to common branch names that exist locally
  for branch in main master develop development; do
    if git -C "$ROOT_REPO" show-ref --verify --quiet "refs/heads/$branch"; then
      echo "$branch"
      return
    fi
  done
  
  # Last resort: get the first local branch
  local first_branch=$(git -C "$ROOT_REPO" branch --format='%(refname:short)' | head -n1)
  if [[ -n "$first_branch" ]]; then
    echo "$first_branch"
  else
    echo "main"  # Ultimate fallback
  fi
}

function validate_branch_exists() {
  local branch="$1"
  git -C "$ROOT_REPO" show-ref --verify --quiet "refs/heads/$branch"
}

function list_available_branches() {
  git -C "$ROOT_REPO" branch --format='%(refname:short)' | tr '\n' ', ' | sed 's/, $//'
}

function get_latest_tag() {
  git -C "$ROOT_REPO" describe --tags --abbrev=0 2>/dev/null
}

function list_available_tags() {
  git -C "$ROOT_REPO" tag --sort=-version:refname | head -10 | tr '\n' ', ' | sed 's/, $//'
}

function validate_tag_exists() {
  local tag="$1"
  git -C "$ROOT_REPO" show-ref --verify --quiet "refs/tags/$tag"
}

function get_gitignore_patterns() {
  if [[ -f "$ROOT_REPO/.gitignore" ]]; then
    # Extract patterns that likely represent dependencies/build artifacts to preserve
    grep -E '^(node_modules|\.env|dist|build|coverage|\.next|\.nuxt|target|\.gradle|\.idea|\.vscode|\.DS_Store)' "$ROOT_REPO/.gitignore" 2>/dev/null | grep -v '^#'
  fi
}

function copy_preserved_files() {
  local dest_path="$1"
  local patterns=$(get_gitignore_patterns)
  
  if [[ -n "$patterns" ]]; then
    echo "üì¶ Copying preserved files..."
    while IFS= read -r pattern; do
      # Remove leading/trailing whitespace and skip empty lines
      pattern=$(echo "$pattern" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
      [[ -z "$pattern" ]] && continue
      
      # Find all instances of this pattern recursively
      if [[ "$pattern" =~ ^\. ]]; then
        # Hidden files/directories (like .env, .DS_Store)
        while IFS= read -r -d '' src_file; do
          if [[ -f "$src_file" ]] || [[ -d "$src_file" ]]; then
            # Get relative path from root repo
            local rel_path="${src_file#$ROOT_REPO/}"
            local dest_dir="$dest_path/$(dirname "$rel_path")"
            mkdir -p "$dest_dir"
            cp -R "$src_file" "$dest_dir/" 2>/dev/null
            echo "  ‚úì Copied $rel_path"
          fi
        done < <(find "$ROOT_REPO" -name "$pattern" -print0 2>/dev/null)
      else
        # Regular directories (like node_modules, dist)
        while IFS= read -r -d '' src_dir; do
          if [[ -d "$src_dir" ]]; then
            # Get relative path from root repo
            local rel_path="${src_dir#$ROOT_REPO/}"
            local dest_dir="$dest_path/$(dirname "$rel_path")"
            mkdir -p "$dest_dir"
            cp -R "$src_dir" "$dest_dir/" 2>/dev/null
            echo "  ‚úì Copied $rel_path"
          fi
        done < <(find "$ROOT_REPO" -name "$pattern" -type d -print0 2>/dev/null)
      fi
    done <<< "$patterns"
  fi
}

function create_session() {
  # Get branch name
  branch=$(gum input --placeholder "New branch name (e.g. fix/gh-1083)")
  if [ -z "$branch" ]; then
    echo "üö´ No branch name provided."
    return
  fi

  # Detect smart default and update DEFAULT_BASE_BRANCH if needed
  if [[ -z "$DEFAULT_BASE_BRANCH" ]] || [[ "$DEFAULT_BASE_BRANCH" == "main" ]]; then
    smart_default=$(detect_default_branch)
    if [[ "$smart_default" != "$DEFAULT_BASE_BRANCH" ]]; then
      DEFAULT_BASE_BRANCH="$smart_default"
    fi
  fi

  # Ask user to choose between branch or tag
  source_type=$(gum choose --header "What should this new worktree branch from?" "üìã Branch" "üè∑Ô∏è Tag (latest)" "üè∑Ô∏è Tag (specify)")
  
  if [[ "$source_type" == "üìã Branch" ]]; then
    while true; do
      # Show clear prompt with helper text
      base=$(gum input --header "Which branch should this new worktree branch from?" --placeholder "Base branch to create from" --value "$DEFAULT_BASE_BRANCH")
      if [ -z "$base" ]; then
        echo "üö´ No base branch provided."
        return
      fi

      # Validate that the branch exists
      if validate_branch_exists "$base"; then
        break
      else
        available_branches=$(list_available_branches)
        echo "‚ùå Branch '$base' does not exist. Available branches: $available_branches"
        
        retry_choice=$(gum choose --header "What would you like to do?" "üîÑ Try again" "‚ùå Cancel")
        if [[ "$retry_choice" == "‚ùå Cancel" ]]; then
          return
        fi
        # Continue loop to try again
      fi
    done
  elif [[ "$source_type" == "üè∑Ô∏è Tag (latest)" ]]; then
    base=$(get_latest_tag)
    if [ -z "$base" ]; then
      echo "‚ùå No tags found in this repository."
      return
    fi
    echo "üìå Using latest tag: $base"
  else # Tag (specify)
    latest_tag=$(get_latest_tag)
    available_tags=$(list_available_tags)
    echo "üí° Latest tag: $latest_tag"
    echo "üìã Recent tags: $available_tags"
    
    while true; do
      base=$(gum input --header "Which tag should this new worktree branch from?" --placeholder "Tag name (e.g. v1.0.1)" --value "$latest_tag")
      if [ -z "$base" ]; then
        echo "üö´ No tag provided."
        return
      fi

      # Validate that the tag exists
      if validate_tag_exists "$base"; then
        break
      else
        echo "‚ùå Tag '$base' does not exist. Available tags: $available_tags"
        
        retry_choice=$(gum choose --header "What would you like to do?" "üîÑ Try again" "‚ùå Cancel")
        if [[ "$retry_choice" == "‚ùå Cancel" ]]; then
          return
        fi
        # Continue loop to try again
      fi
    done
  fi

  # Save new default if different (only for branches)
  if [[ "$source_type" == "üìã Branch" ]] && [[ "$base" != "$DEFAULT_BASE_BRANCH" ]]; then
    echo "DEFAULT_BASE_BRANCH=$base" > "$CONFIG_FILE"
    echo "üìÅ Saved '$base' as default base branch for this repo."
    DEFAULT_BASE_BRANCH="$base"
  fi

  # Ask about preserving dependencies
  preserve_deps="No"
  if [[ -n "$(get_gitignore_patterns)" ]]; then
    preserve_deps=$(gum choose --header "Copy dependencies from main repo?" "üì¶ Yes (faster setup)" "üßπ No (fresh start)")
  fi

  # Generate unique session ID
  session_id=$(generate_session_id)
  path="$SESSIONS_DIR/$session_id"
  
  # Create the worktree with UUID-based directory
  if git -C "$ROOT_REPO" worktree add "$path" -b "$branch" "$base" 2>/dev/null; then
    # Add session to registry with all metadata
    add_session_to_registry "$session_id" "$branch" "$base"
    
    if [[ "$source_type" == "üìã Branch" ]]; then
      echo "‚úÖ Worktree created: $session_id -> '$branch' (from branch $base)"
    else
      echo "‚úÖ Worktree created: $session_id -> '$branch' (from tag $base)"
    fi
    
    # Copy preserved files if requested
    if [[ "$preserve_deps" == "üì¶ Yes (faster setup)" ]]; then
      copy_preserved_files "$path"
    fi
    
    open_session "$session_id"
    echo "üéâ Session ready! Return to main menu to launch it."
  else
    echo "‚ùå Failed to create worktree. The branch '$branch' may already exist."
  fi
}

function delete_session() {
  local session_id="$1"
  local path="$SESSIONS_DIR/$session_id"
  
  # Get the actual branch name from registry
  local branch=$(get_session_info "$session_id" "branch")
  
  if [[ -z "$branch" ]]; then
    echo "‚ùå Session '$session_id' not found in registry."
    return 1
  fi
  
  gum confirm "Delete session '$session_id' (branch: $branch)?" && {
    # Remove worktree
    if git -C "$ROOT_REPO" worktree remove "$path" 2>/dev/null; then
      echo "‚úÖ Removed worktree: $path"
    else
      echo "‚ö†Ô∏è  Worktree removal failed or already removed"
    fi
    
    # Delete the actual branch using the stored name
    if git -C "$ROOT_REPO" branch -D "$branch" 2>/dev/null; then
      echo "‚úÖ Deleted branch: $branch"
    else
      echo "‚ö†Ô∏è  Branch deletion failed or already deleted"
    fi
    
    # Remove from registry
    remove_session_from_registry "$session_id"
    echo "üóëÔ∏è  Cleaned up session: $session_id"
  }
}

function launch_in_terminal() {
  local path="$1"
  local claude_cmd="$2"
  
  osascript <<EOF
tell application "Terminal"
  do script "cd \"$path\" && $claude_cmd"
  activate
end tell
EOF
}

function launch_in_iterm() {
  local path="$1"
  local claude_cmd="$2"
  
  osascript <<EOF
tell application "iTerm2"
  create window with default profile
  tell current session of current window
    write text "cd \"$path\" && $claude_cmd"
  end tell
  activate
end tell
EOF
}

function open_session() {
  local session_id="$1"
  local path="$SESSIONS_DIR/$session_id"
  
  # Build claude command with common options (always use pure Sonnet)
  claude_cmd="claude --model sonnet"
  
  # Quick launch options - only show if we have common use cases
  launch_option=$(gum choose --header "Launch Claude with:" "üöÄ Standard" "‚ö° Skip permissions" "üîÑ Resume session" "‚öôÔ∏è Custom flags" "‚ùå Cancel")
  
  case $launch_option in
    "‚ö° Skip permissions")
      claude_cmd="claude --model sonnet --dangerously-skip-permissions"
      ;;
    "üîÑ Resume session")
      claude_cmd="claude --model sonnet --resume"
      ;;
    "‚öôÔ∏è Custom flags")
      flags=$(gum input --placeholder "Additional flags (e.g. --resume --dangerously-skip-permissions)")
      if [[ -n "$flags" ]]; then
        claude_cmd="claude --model sonnet $flags"
      else
        claude_cmd="claude --model sonnet"
      fi
      ;;
    "‚ùå Cancel")
      return  # Exit without launching anything
      ;;
    *)
      claude_cmd="claude --model sonnet"
      ;;
  esac
  
  # Choose terminal application
  terminal_choice=$(gum choose --header "Choose terminal:" "üíª Terminal" "üöÄ iTerm" "‚ùå Cancel")
  
  case $terminal_choice in
    "üíª Terminal")
      launch_in_terminal "$path" "$claude_cmd"
      ;;
    "üöÄ iTerm")
      # Check if iTerm is installed
      if ! osascript -e 'tell application "System Events" to return (exists application process "iTerm2")' 2>/dev/null && ! ls /Applications/iTerm.app 2>/dev/null >/dev/null; then
        echo "‚ö†Ô∏è  iTerm not found. Falling back to Terminal."
        launch_in_terminal "$path" "$claude_cmd"
      else
        launch_in_iterm "$path" "$claude_cmd"
      fi
      ;;
    "‚ùå Cancel")
      return  # Exit without launching anything
      ;;
  esac
}

function open_vscode() {
  local session_id="$1"
  local path="$SESSIONS_DIR/$session_id"
  code "$path"
}

function format_session_display() {
  local session_id="$1"
  local branch=$(get_session_info "$session_id" "branch")
  local base_branch=$(get_session_info "$session_id" "baseBranch")
  
  if [[ -n "$branch" ]]; then
    echo "$session_id ‚Üí $branch (from $base_branch)"
  else
    echo "$session_id (unknown branch)"
  fi
}

function dashboard() {
  while true; do
    options=()
    declare -A session_map
    
    # Build display options and maintain session ID mapping
    while IFS= read -r session_id; do
      [[ -z "$session_id" ]] && continue
      display_name=$(format_session_display "$session_id")
      options+=("$display_name")
      session_map["$display_name"]="$session_id"
    done < <(list_sessions_array)

    options+=("‚ûï New Session")
    options+=("‚ùå Exit")

    choice=$(printf "%s\n" "${options[@]}" | gum choose --header="üß† Clawtree Sessions")

    if [[ "$choice" == "‚ûï New Session" ]]; then
      create_session
    elif [[ "$choice" == "‚ùå Exit" ]]; then
      break
    elif [[ -n "$choice" ]]; then
      # Extract session ID from display choice
      session_id="${session_map[$choice]}"
      
      if [[ -n "$session_id" ]]; then
        gum style --bold "Selected: $choice"
        action=$(gum choose "üí¨ Launch Claude" "üíª Open in VS Code" "ü§ñ Launch Both" "üóëÔ∏è Delete Session" "‚ùå Cancel")

        case $action in
          "üí¨ Launch Claude")
            open_session "$session_id"
            ;;
          "üíª Open in VS Code")
            open_vscode "$session_id"
            ;;
          "ü§ñ Launch Both")
            open_vscode "$session_id"
            open_session "$session_id"
            ;;
          "üóëÔ∏è Delete Session")
            delete_session "$session_id"
            ;;
          "‚ùå Cancel")
            ;;
        esac
      fi
    fi
  done
}

dashboard
