#!/bin/bash

ROOT_REPO=$(git rev-parse --show-toplevel 2>/dev/null)
if [[ -z "$ROOT_REPO" ]]; then
  echo "ğŸš« Not inside a git repository."
  exit 1
fi

SESSIONS_DIR="$ROOT_REPO/.clawtree-sessions"
CONFIG_FILE="$ROOT_REPO/.clawtree-config"

mkdir -p "$SESSIONS_DIR"

if [[ -f "$CONFIG_FILE" ]]; then
  source "$CONFIG_FILE"
else
  DEFAULT_BASE_BRANCH="main"
fi

function list_sessions_array() {
  ls "$SESSIONS_DIR" 2>/dev/null
}

function detect_default_branch() {
  # Try to get the remote HEAD first
  local remote_head=$(git -C "$ROOT_REPO" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's|refs/remotes/origin/||')
  if [[ -n "$remote_head" ]] && git -C "$ROOT_REPO" show-ref --verify --quiet "refs/heads/$remote_head"; then
    echo "$remote_head"
    return
  fi
  
  # Fallback to common branch names that exist locally
  for branch in main master develop development; do
    if git -C "$ROOT_REPO" show-ref --verify --quiet "refs/heads/$branch"; then
      echo "$branch"
      return
    fi
  done
  
  # Last resort: get the first local branch
  local first_branch=$(git -C "$ROOT_REPO" branch --format='%(refname:short)' | head -n1)
  if [[ -n "$first_branch" ]]; then
    echo "$first_branch"
  else
    echo "main"  # Ultimate fallback
  fi
}

function validate_branch_exists() {
  local branch="$1"
  git -C "$ROOT_REPO" show-ref --verify --quiet "refs/heads/$branch"
}

function list_available_branches() {
  git -C "$ROOT_REPO" branch --format='%(refname:short)' | tr '\n' ', ' | sed 's/, $//'
}

function get_latest_tag() {
  git -C "$ROOT_REPO" describe --tags --abbrev=0 2>/dev/null
}

function list_available_tags() {
  git -C "$ROOT_REPO" tag --sort=-version:refname | head -10 | tr '\n' ', ' | sed 's/, $//'
}

function validate_tag_exists() {
  local tag="$1"
  git -C "$ROOT_REPO" show-ref --verify --quiet "refs/tags/$tag"
}

function get_gitignore_patterns() {
  if [[ -f "$ROOT_REPO/.gitignore" ]]; then
    # Extract patterns that likely represent dependencies/build artifacts to preserve
    grep -E '^(node_modules|\.env|dist|build|coverage|\.next|\.nuxt|target|\.gradle|\.idea|\.vscode|\.DS_Store)' "$ROOT_REPO/.gitignore" 2>/dev/null | grep -v '^#'
  fi
}

function copy_preserved_files() {
  local dest_path="$1"
  local patterns=$(get_gitignore_patterns)
  
  if [[ -n "$patterns" ]]; then
    echo "ğŸ“¦ Copying preserved files..."
    while IFS= read -r pattern; do
      # Remove leading/trailing whitespace and skip empty lines
      pattern=$(echo "$pattern" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
      [[ -z "$pattern" ]] && continue
      
      # Find all instances of this pattern recursively
      if [[ "$pattern" =~ ^\. ]]; then
        # Hidden files/directories (like .env, .DS_Store)
        while IFS= read -r -d '' src_file; do
          if [[ -f "$src_file" ]] || [[ -d "$src_file" ]]; then
            # Get relative path from root repo
            local rel_path="${src_file#$ROOT_REPO/}"
            local dest_dir="$dest_path/$(dirname "$rel_path")"
            mkdir -p "$dest_dir"
            cp -R "$src_file" "$dest_dir/" 2>/dev/null
            echo "  âœ“ Copied $rel_path"
          fi
        done < <(find "$ROOT_REPO" -name "$pattern" -print0 2>/dev/null)
      else
        # Regular directories (like node_modules, dist)
        while IFS= read -r -d '' src_dir; do
          if [[ -d "$src_dir" ]]; then
            # Get relative path from root repo
            local rel_path="${src_dir#$ROOT_REPO/}"
            local dest_dir="$dest_path/$(dirname "$rel_path")"
            mkdir -p "$dest_dir"
            cp -R "$src_dir" "$dest_dir/" 2>/dev/null
            echo "  âœ“ Copied $rel_path"
          fi
        done < <(find "$ROOT_REPO" -name "$pattern" -type d -print0 2>/dev/null)
      fi
    done <<< "$patterns"
  fi
}

function create_session() {
  # Get branch name
  branch=$(gum input --placeholder "New branch name (e.g. fix/gh-1083)")
  if [ -z "$branch" ]; then
    echo "ğŸš« No branch name provided."
    return
  fi

  # Detect smart default and update DEFAULT_BASE_BRANCH if needed
  if [[ -z "$DEFAULT_BASE_BRANCH" ]] || [[ "$DEFAULT_BASE_BRANCH" == "main" ]]; then
    smart_default=$(detect_default_branch)
    if [[ "$smart_default" != "$DEFAULT_BASE_BRANCH" ]]; then
      DEFAULT_BASE_BRANCH="$smart_default"
    fi
  fi

  # Ask user to choose between branch or tag
  source_type=$(gum choose --header "What should this new worktree branch from?" "ğŸ“‹ Branch" "ğŸ·ï¸ Tag (latest)" "ğŸ·ï¸ Tag (specify)")
  
  if [[ "$source_type" == "ğŸ“‹ Branch" ]]; then
    while true; do
      # Show clear prompt with helper text
      base=$(gum input --header "Which branch should this new worktree branch from?" --placeholder "Base branch to create from" --value "$DEFAULT_BASE_BRANCH")
      if [ -z "$base" ]; then
        echo "ğŸš« No base branch provided."
        return
      fi

      # Validate that the branch exists
      if validate_branch_exists "$base"; then
        break
      else
        available_branches=$(list_available_branches)
        echo "âŒ Branch '$base' does not exist. Available branches: $available_branches"
        
        retry_choice=$(gum choose --header "What would you like to do?" "ğŸ”„ Try again" "âŒ Cancel")
        if [[ "$retry_choice" == "âŒ Cancel" ]]; then
          return
        fi
        # Continue loop to try again
      fi
    done
  elif [[ "$source_type" == "ğŸ·ï¸ Tag (latest)" ]]; then
    base=$(get_latest_tag)
    if [ -z "$base" ]; then
      echo "âŒ No tags found in this repository."
      return
    fi
    echo "ğŸ“Œ Using latest tag: $base"
  else # Tag (specify)
    latest_tag=$(get_latest_tag)
    available_tags=$(list_available_tags)
    echo "ğŸ’¡ Latest tag: $latest_tag"
    echo "ğŸ“‹ Recent tags: $available_tags"
    
    while true; do
      base=$(gum input --header "Which tag should this new worktree branch from?" --placeholder "Tag name (e.g. v1.0.1)" --value "$latest_tag")
      if [ -z "$base" ]; then
        echo "ğŸš« No tag provided."
        return
      fi

      # Validate that the tag exists
      if validate_tag_exists "$base"; then
        break
      else
        echo "âŒ Tag '$base' does not exist. Available tags: $available_tags"
        
        retry_choice=$(gum choose --header "What would you like to do?" "ğŸ”„ Try again" "âŒ Cancel")
        if [[ "$retry_choice" == "âŒ Cancel" ]]; then
          return
        fi
        # Continue loop to try again
      fi
    done
  fi

  # Save new default if different (only for branches)
  if [[ "$source_type" == "ğŸ“‹ Branch" ]] && [[ "$base" != "$DEFAULT_BASE_BRANCH" ]]; then
    echo "DEFAULT_BASE_BRANCH=$base" > "$CONFIG_FILE"
    echo "ğŸ“ Saved '$base' as default base branch for this repo."
    DEFAULT_BASE_BRANCH="$base"
  fi

  # Ask about preserving dependencies
  preserve_deps="No"
  if [[ -n "$(get_gitignore_patterns)" ]]; then
    preserve_deps=$(gum choose --header "Copy dependencies from main repo?" "ğŸ“¦ Yes (faster setup)" "ğŸ§¹ No (fresh start)")
  fi

  # Create the worktree
  path="$SESSIONS_DIR/$(echo $branch | tr '/' '-')"
  if git -C "$ROOT_REPO" worktree add "$path" -b "$branch" "$base" 2>/dev/null; then
    # Store the base branch information for later merge-back capability
    echo "$base" > "$path/.clawtree-base-branch"
    echo "$source_type" > "$path/.clawtree-source-type"
    
    if [[ "$source_type" == "ğŸ“‹ Branch" ]]; then
      echo "âœ… Worktree created: $path (from branch $base)"
    else
      echo "âœ… Worktree created: $path (from tag $base)"
    fi
    
    # Copy preserved files if requested
    if [[ "$preserve_deps" == "ğŸ“¦ Yes (faster setup)" ]]; then
      copy_preserved_files "$path"
    fi
    
    open_session "$(basename "$path")"
  else
    echo "âŒ Failed to create worktree. The branch '$branch' may already exist."
  fi
}

function delete_session() {
  session="$1"
  path="$SESSIONS_DIR/$session"

  gum confirm "Delete session '$session'?" && {
    git -C "$ROOT_REPO" worktree remove "$path"
    git -C "$ROOT_REPO" branch -D "$(echo "$session" | tr '-' '/')"
    echo "âŒ Deleted $session"
  }
}

function open_session() {
  session="$1"
  path="$SESSIONS_DIR/$session"
  
  # Build claude command with common options (always use pure Sonnet)
  claude_cmd="claude --model sonnet"
  
  # Quick launch options - only show if we have common use cases
  launch_option=$(gum choose --header "Launch Claude with:" "ğŸš€ Standard" "âš¡ Skip permissions" "ğŸ”„ Resume session" "âš™ï¸ Custom flags")
  
  case $launch_option in
    "âš¡ Skip permissions")
      claude_cmd="claude --model sonnet --dangerously-skip-permissions"
      ;;
    "ğŸ”„ Resume session")
      claude_cmd="claude --model sonnet --resume"
      ;;
    "âš™ï¸ Custom flags")
      flags=$(gum input --placeholder "Additional flags (e.g. --resume --dangerously-skip-permissions)")
      if [[ -n "$flags" ]]; then
        claude_cmd="claude --model sonnet $flags"
      else
        claude_cmd="claude --model sonnet"
      fi
      ;;
    *)
      claude_cmd="claude --model sonnet"
      ;;
  esac

  osascript <<EOF
tell application "Terminal"
  do script "cd \"$path\" && $claude_cmd"
  activate
end tell
EOF
}

function open_vscode() {
  session="$1"
  path="$SESSIONS_DIR/$session"
  code "$path"
}

function get_base_branch() {
  local session="$1"
  local path="$SESSIONS_DIR/$session"
  
  if [[ -f "$path/.clawtree-base-branch" ]]; then
    cat "$path/.clawtree-base-branch"
  else
    echo ""  # No base branch info found
  fi
}

function get_source_type() {
  local session="$1"
  local path="$SESSIONS_DIR/$session"
  
  if [[ -f "$path/.clawtree-source-type" ]]; then
    cat "$path/.clawtree-source-type"
  else
    echo "ğŸ“‹ Branch"  # Default to branch
  fi
}

function merge_back_to_base() {
  local session="$1"
  local path="$SESSIONS_DIR/$session"
  local branch=$(echo "$session" | tr '-' '/')
  local base_branch=$(get_base_branch "$session")
  local source_type=$(get_source_type "$session")
  
  # Validate that we have base branch info
  if [[ -z "$base_branch" ]]; then
    echo "âŒ Cannot merge: No base branch information found for this session."
    echo "    This may be an older session created before merge-back support."
    return 1
  fi
  
  # Don't allow merging back to tags
  if [[ "$source_type" != "ğŸ“‹ Branch" ]]; then
    echo "âŒ Cannot merge back to a tag. This session was created from: $source_type"
    return 1
  fi
  
  # Validate that base branch still exists
  if ! validate_branch_exists "$base_branch"; then
    echo "âŒ Base branch '$base_branch' no longer exists."
    return 1
  fi
  
  echo "ğŸ”„ Merge Back Summary:"
  echo "  Session: $session"
  echo "  Branch: $branch"
  echo "  Target: $base_branch"
  echo ""
  
  # Check if there are uncommitted changes in the session
  if ! git -C "$path" diff --quiet || ! git -C "$path" diff --cached --quiet; then
    echo "âš ï¸  Warning: Uncommitted changes detected in session."
    commit_first=$(gum choose --header "What would you like to do?" "ğŸ’¾ Commit changes first" "ğŸ§¨ Stash changes and continue" "âŒ Cancel merge")
    
    case $commit_first in
      "ğŸ’¾ Commit changes first")
        echo "ğŸ“ Please commit your changes in the session, then try merge again."
        return 1
        ;;
      "ğŸ§¨ Stash changes and continue")
        echo "ğŸ§¨ Stashing uncommitted changes..."
        git -C "$path" stash push -m "clawtree: stashed before merge back to $base_branch"
        ;;
      "âŒ Cancel merge")
        return 1
        ;;
    esac
  fi
  
  # Final confirmation
  if ! gum confirm "Proceed with merging '$branch' into '$base_branch'?"; then
    return 1
  fi
  
  echo "ğŸ”„ Starting merge process..."
  
  # Switch to base branch in main repo
  if ! git -C "$ROOT_REPO" checkout "$base_branch" 2>/dev/null; then
    echo "âŒ Failed to checkout base branch '$base_branch'"
    return 1
  fi
  
  # Pull latest changes (if remote tracking exists)
  if git -C "$ROOT_REPO" rev-parse --abbrev-ref "$base_branch@{upstream}" >/dev/null 2>&1; then
    echo "ğŸ”„ Pulling latest changes for $base_branch..."
    git -C "$ROOT_REPO" pull
  fi
  
  # Perform the merge
  if git -C "$ROOT_REPO" merge "$branch" --no-ff -m "Merge branch '$branch' (from clawtree session $session)" 2>/dev/null; then
    echo "âœ… Successfully merged '$branch' into '$base_branch'"
    
    # Ask if user wants to delete the session after successful merge
    if gum confirm "Merge successful! Delete the clawtree session '$session'?"; then
      delete_session "$session"
    else
      echo "ğŸ“ Session '$session' kept for reference."
    fi
  else
    echo "âŒ Merge failed! There may be conflicts that need manual resolution."
    echo "    You can resolve conflicts in the main repo and complete the merge manually."
    return 1
  fi
}

function dashboard() {
  while true; do
    options=()
    while IFS= read -r session; do
      options+=("$session")
    done < <(list_sessions_array)

    options+=("â• New Session")
    options+=("âŒ Exit")

    choice=$(printf "%s\n" "${options[@]}" | gum choose --header="ğŸ§  Clawtree Sessions")

    if [[ "$choice" == "â• New Session" ]]; then
      create_session
    elif [[ "$choice" == "âŒ Exit" ]]; then
      break
    elif [[ -n "$choice" ]]; then
      gum style --bold "Selected: $choice"
      
      # Check if this session supports merge back
      base_branch=$(get_base_branch "$choice")
      source_type=$(get_source_type "$choice")
      
      if [[ -n "$base_branch" ]] && [[ "$source_type" == "ğŸ“‹ Branch" ]]; then
        action=$(gum choose "ğŸ’¬ Launch Claude" "ğŸ’» Open in VS Code" "ğŸ¤– Launch Both" "ğŸ”„ Merge Back to $base_branch" "ğŸ—‘ï¸ Delete Session" "âŒ Cancel")
      else
        action=$(gum choose "ğŸ’¬ Launch Claude" "ğŸ’» Open in VS Code" "ğŸ¤– Launch Both" "ğŸ—‘ï¸ Delete Session" "âŒ Cancel")
      fi

      case $action in
        "ğŸ’¬ Launch Claude")
          open_session "$choice"
          ;;
        "ğŸ’» Open in VS Code")
          open_vscode "$choice"
          ;;
        "ğŸ¤– Launch Both")
          open_vscode "$choice"
          open_session "$choice"
          ;;
        "ğŸ”„ Merge Back to"*)
          merge_back_to_base "$choice"
          ;;
        "ğŸ—‘ï¸ Delete Session")
          delete_session "$choice"
          ;;
        "âŒ Cancel")
          ;;
      esac
    fi
  done
}

dashboard
